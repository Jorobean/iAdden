<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <title>Camera</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            margin: 0;
            padding: 0;
            height: 100vh;
            width: 100vw;
            overflow: hidden;
            background: #000;
            position: fixed;
        }

        .video-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #cameraVideo {
            width: 100%;
            height: 100%;
            object-fit: cover;
            /* Mirror the video feed for selfie view */
            transform: scaleX(-1);
        }

        video::-webkit-media-controls {
            display: none !important;
        }
        
        /* PiP mirroring styles */
        :picture-in-picture #cameraVideo,
        #cameraVideo:picture-in-picture {
            transform: scaleX(-1) !important;
        }

        @media all and (display-mode: picture-in-picture) {
            #cameraVideo {
                transform: scaleX(-1) !important;
            }
        }

        .pip-button {
            white-space: nowrap;
            display: inline-flex;
            background: rgba(0,0,0,0.5);
            border: none;
            padding: 12px 20px;
            border-radius: 20px;
            color: white;
            font-family: -apple-system, system-ui, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            font-size: 14px;
            cursor: pointer;
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            transition: background-color 0.3s;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .pip-button:hover {
            background: rgba(0,0,0,0.7);
        }

        .controls-container {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 20px;
            align-items: center;
            z-index: 1000;
        }

        .pip-container, .light-container {
            display: flex;
            align-items: center;
        }

        .light-button.active {
            background: rgba(255,255,255,0.3);
            box-shadow: 0 0 15px rgba(255,255,255,0.5);
        }

        .light-button.active svg {
            fill: #FFD700;
            opacity: 1;
        }

        .pip-button, .light-button {
            background: rgba(0,0,0,0.5);
            border: none;
            padding: 12px 20px;
            border-radius: 20px;
            color: white;
            font-family: -apple-system, system-ui, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            font-size: 14px;
            cursor: pointer;
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            transition: background-color 0.3s;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .pip-button svg, .light-button svg {
            width: 20px;
            height: 20px;
            fill: white;
        }

        .controls-container {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            z-index: 1000;
        }
    </style>
</head>
<body>
    <div class="video-container">
        <video id="cameraVideo" autoplay playsinline muted="true" defaultMuted disableRemotePlayback></video>
        <div class="controls-container">
            <div class="pip-container">
                <button class="pip-button" id="pipBtn">
                <svg viewBox="0 0 24 24">
                    <path d="M19 7h-8v6h8V7zm2-4H3C2 3 1 4 1 5v14c0 1 1 2 2 2h18c1 0 2-1 2-2V5c0-1-1-2-2-2zm0 16H3V5h18v14z"/>
                </svg>
                Picture in Picture
            </button>
            </div>
        </div>
    </div>

    <script>
        const cameraVideo = document.getElementById('cameraVideo');
        const pipBtn = document.getElementById('pipBtn');
        let currentFacingMode = 'user';

        // Initialize camera
        async function initCamera() {
            try {
                const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
                
                const constraints = {
                    video: {
                        facingMode: currentFacingMode,
                        width: { min: 1280, ideal: 1920 },  // 1080p quality
                        height: { min: 720, ideal: 1080 },
                        frameRate: { ideal: 60, min: 30 },  // 60fps for smooth video
                        aspectRatio: 16/9,                  // Maintain aspect ratio
                        resizeMode: 'crop-and-scale'        // Ensure full coverage
                    },
                    audio: {
                        echoCancellation: false,           // Disable echo cancellation for mixing
                        noiseSuppression: false,           // Disable noise suppression for natural sound
                        autoGainControl: false,            // Disable auto gain for consistent levels
                        volume: 0.75,                      // Set mic volume to 75%
                        sampleRate: 48000,                 // High quality audio
                        sampleSize: 24,                    // 24-bit audio depth
                        channelCount: 2,                   // Stereo audio
                        latency: 0                         // Minimum latency
                    }
                };

                // Function to ensure highest quality
                const ensureHighQuality = async (track) => {
                    const capabilities = track.getCapabilities();
                    const settings = {
                        width: Math.min(capabilities.width?.max || 1920, 1920),  // Up to 1080p width
                        height: Math.min(capabilities.height?.max || 1080, 1080), // Up to 1080p height
                        frameRate: Math.min(capabilities.frameRate?.max || 60, 60), // Up to 60fps
                        resizeMode: 'crop-and-scale'
                    };
                    await track.applyConstraints(settings);
                };

                const stream = await navigator.mediaDevices.getUserMedia(constraints);
                
                // Apply highest quality settings to video track
                const videoTrack = stream.getVideoTracks()[0];
                if (videoTrack) {
                    await ensureHighQuality(videoTrack);
                }

                // Configure audio track for screen recording with mixing
                const audioTrack = stream.getAudioTracks()[0];
                if (audioTrack) {
                    // Set microphone volume to 75% for mixing with device audio
                    await audioTrack.applyConstraints({
                        volume: 0.75,
                        echoCancellation: false,
                        noiseSuppression: false,
                        autoGainControl: false,
                        sampleRate: 48000,
                        sampleSize: 24,
                        latency: 0
                    });
                }

                cameraVideo.srcObject = stream;
                
                // Set video element properties - ensure it's the primary video for PiP
                cameraVideo.setAttribute('playsinline', true);
                cameraVideo.setAttribute('webkit-playsinline', true);
                cameraVideo.style.objectFit = 'cover';
                
                // Mark this video as the preferred PiP source
                cameraVideo.setAttribute('data-pip-source', 'camera');
                cameraVideo.disablePictureInPicture = false;
                
                // Mute the video element to prevent feedback but keep audio track active
                cameraVideo.muted = true;
                
                // Ensure video starts playing immediately
                await cameraVideo.play();

                // Hide PiP button if not supported
                if (!document.pictureInPictureEnabled) {
                    pipBtn.style.display = 'none';
                }
            } catch (err) {
                console.error('Error accessing camera:', err);
                alert('Unable to access camera. Please ensure you have granted camera permissions.');
            }
        }

        // Enhanced PiP handling with aggressive persistence
        let pipKeepAliveInterval = null;
        let pipRecoveryInterval = null;

        // PiP functionality
        pipBtn.addEventListener('click', async () => {
            try {
                if (document.pictureInPictureElement) {
                    await document.exitPictureInPicture();
                    pipBtn.innerHTML = `
                        <svg viewBox="0 0 24 24">
                            <path d="M19 7h-8v6h8V7zm2-4H3C2 3 1 4 1 5v14c0 1 1 2 2 2h18c1 0 2-1 2-2V5c0-1-1-2-2-2zm0 16H3V5h18v14z"/>
                        </svg>
                        Picture in Picture`;
                } else if (document.pictureInPictureEnabled) {
                    const pipWindow = await cameraVideo.requestPictureInPicture();
                    pipBtn.innerHTML = `
                        <svg viewBox="0 0 24 24">
                            <path d="M19 11h-8v6h8v-6zm4 8V4.98C23 3.88 22.1 3 21 3H3c-1.1 0-2 .88-2 1.98V19c0 1.1.9 2 2 2h18c1.1 0 2-.9 2-2zm-2 .02H3V4.97h18v14.05z"/>
                        </svg>
                        Exit PiP`;
                }
            } catch (err) {
                console.error('PiP error:', err);
                alert('Picture-in-Picture mode failed. This feature may not be supported in your browser.');
            }
        });

        cameraVideo.addEventListener('enterpictureinpicture', () => {
            console.log('Entered PiP mode - Activating enhanced persistence');
            
            // Primary keep-alive mechanism for PiP
            pipKeepAliveInterval = setInterval(() => {
                if (document.pictureInPictureElement) {
                    const pipElement = document.pictureInPictureElement;
                    if (pipElement.paused || pipElement.ended) {
                        console.log('PiP paused/ended, force resuming...');
                        pipElement.muted = true;
                        pipElement.volume = 0;
                        pipElement.play().catch(err => {
                            console.log('PiP resume failed:', err);
                        });
                    }
                    
                    // Ensure proper mirroring in PiP
                    if (pipElement.style.transform !== 'scaleX(-1)') {
                        pipElement.style.transform = 'scaleX(-1)';
                    }
                }
            }, 500); // Check every 500ms for more aggressive monitoring
            
            // Secondary recovery mechanism
            pipRecoveryInterval = setInterval(() => {
                if (document.pictureInPictureElement && document.pictureInPictureElement !== cameraVideo) {
                    console.log('PiP element mismatch detected, correcting...');
                    // Attempt to restore proper PiP
                    document.exitPictureInPicture().then(() => {
                        setTimeout(() => {
                            cameraVideo.requestPictureInPicture().catch(() => {});
                        }, 500);
                    }).catch(() => {});
                }
            }, 2000);
            
            // Ensure PiP video properties
            setTimeout(() => {
                if (document.pictureInPictureElement) {
                    const pipElement = document.pictureInPictureElement;
                    pipElement.muted = true;
                    pipElement.volume = 0;
                    pipElement.style.transform = 'scaleX(-1)';
                    pipElement.play().catch(() => {});
                }
            }, 100);
        });

        cameraVideo.addEventListener('leavepictureinpicture', () => {
            console.log('Left PiP mode - Maintaining camera playback');
            
            // Clear PiP-specific intervals
            if (pipKeepAliveInterval) {
                clearInterval(pipKeepAliveInterval);
                pipKeepAliveInterval = null;
            }
            if (pipRecoveryInterval) {
                clearInterval(pipRecoveryInterval);
                pipRecoveryInterval = null;
            }
            
            // Update button
            pipBtn.innerHTML = `
                <svg viewBox="0 0 24 24">
                    <path d="M19 7h-8v6h8V7zm2-4H3C2 3 1 4 1 5v14c0 1 1 2 2 2h18c1 0 2-1 2-2V5c0-1-1-2-2-2zm0 16H3V5h18v14z"/>
                </svg>
                Picture in Picture`;
            
            // Ensure main video continues playing
            setTimeout(() => {
                if (!isUserPaused) {
                    resumeCamera();
                }
            }, 100);
        });

        // Handle iOS app switching and multitasking
        window.addEventListener('pagehide', () => {
            // Keep tracks active when page is hidden
            if (cameraStream) {
                cameraStream.getVideoTracks().forEach(track => {
                    if (track.readyState === 'live') {
                        track.enabled = true;
                    }
                });
                cameraStream.getAudioTracks().forEach(track => {
                    if (track.readyState === 'live') {
                        track.enabled = true;
                    }
                });
            }
        });

        window.addEventListener('pageshow', () => {
            // Resume when page becomes visible again
            setTimeout(resumeCamera, 200);
        });

        // Handle focus changes
        window.addEventListener('blur', () => {
            // Don't pause when losing focus
            setTimeout(() => {
                if (cameraVideo.paused && !isUserPaused) {
                    resumeCamera();
                }
            }, 100);
        });

        window.addEventListener('focus', () => {
            // Resume when gaining focus
            setTimeout(resumeCamera, 100);
        });

        // Advanced media session handling for background operation
        let cameraStream = null;
        let isUserPaused = false;
        let persistenceActive = true;
        let recoveryAttempts = 0;
        const MAX_RECOVERY_ATTEMPTS = 5;
        
        // Store the original stream for persistence
        cameraVideo.addEventListener('loadedmetadata', () => {
            cameraStream = cameraVideo.srcObject;
        });

        // Enhanced media session configuration
        if ('mediaSession' in navigator) {
            // Set minimal metadata to avoid conflicts
            navigator.mediaSession.metadata = new MediaMetadata({
                title: 'Camera',
                artist: 'Background',
                artwork: []
            });
            
            // Override default media session handlers to prevent interference
            navigator.mediaSession.setActionHandler('play', null);
            navigator.mediaSession.setActionHandler('pause', null);
            navigator.mediaSession.setActionHandler('stop', null);
            navigator.mediaSession.setActionHandler('seekbackward', null);
            navigator.mediaSession.setActionHandler('seekforward', null);
            navigator.mediaSession.setActionHandler('previoustrack', null);
            navigator.mediaSession.setActionHandler('nexttrack', null);
        }

        // Comprehensive pause prevention system
        const resumeCamera = () => {
            if (cameraStream && cameraVideo.srcObject && !isUserPaused && persistenceActive) {
                // Ensure video tracks are active
                const videoTracks = cameraStream.getVideoTracks();
                const audioTracks = cameraStream.getAudioTracks();
                
                if (videoTracks.length > 0 && videoTracks[0].readyState === 'live') {
                    cameraVideo.muted = true; // Always keep muted to prevent feedback
                    cameraVideo.volume = 0;   // Extra insurance
                    
                    const playPromise = cameraVideo.play();
                    if (playPromise !== undefined) {
                        playPromise.then(() => {
                            console.log('Camera resumed successfully');
                            recoveryAttempts = 0; // Reset on success
                        }).catch(err => {
                            console.log('Resume attempt failed:', err);
                            recoveryAttempts++;
                            
                            if (recoveryAttempts < MAX_RECOVERY_ATTEMPTS) {
                                // Progressive backoff strategy
                                const delay = Math.min(1000 * Math.pow(2, recoveryAttempts), 10000);
                                setTimeout(() => {
                                    if (!isUserPaused && persistenceActive) {
                                        // Try alternative recovery methods
                                        cameraVideo.load();
                                        setTimeout(resumeCamera, 200);
                                    }
                                }, delay);
                            } else {
                                console.log('Max recovery attempts reached, reinitializing camera...');
                                recoveryAttempts = 0;
                                setTimeout(() => initCamera(), 2000);
                            }
                        });
                    }
                }
            }
        };

        // Multiple event listeners to catch all pause scenarios
        cameraVideo.addEventListener('pause', (event) => {
            console.log('Camera paused, attempting resume...');
            if (!isUserPaused) {
                setTimeout(resumeCamera, 50);
                setTimeout(resumeCamera, 200);
                setTimeout(resumeCamera, 500);
                setTimeout(resumeCamera, 1000);
            }
        });
        
        // Enhanced media conflict detection and handling
        let otherMediaElements = new Set();
        let mediaObserver = null;
        
        // Monitor all media elements on the page
        const observeMediaElements = () => {
            // Find all existing media elements
            const allMedia = document.querySelectorAll('video, audio');
            allMedia.forEach(el => {
                if (el !== cameraVideo) {
                    otherMediaElements.add(el);
                    
                    // Listen for play events on other media
                    el.addEventListener('play', () => {
                        console.log('Other media started playing, maintaining camera...');
                        setTimeout(resumeCamera, 50);
                    });
                    
                    el.addEventListener('playing', () => {
                        setTimeout(resumeCamera, 100);
                    });
                }
            });
            
            // Watch for dynamically added media elements
            if (!mediaObserver) {
                mediaObserver = new MutationObserver((mutations) => {
                    mutations.forEach(mutation => {
                        mutation.addedNodes.forEach(node => {
                            if (node.nodeType === 1) { // Element node
                                const newMedia = node.matches && node.matches('video, audio') ? [node] : 
                                                node.querySelectorAll ? node.querySelectorAll('video, audio') : [];
                                
                                newMedia.forEach(el => {
                                    if (el !== cameraVideo && !otherMediaElements.has(el)) {
                                        otherMediaElements.add(el);
                                        console.log('New media element detected:', el.tagName);
                                        
                                        el.addEventListener('play', () => {
                                            console.log('New media playing, maintaining camera...');
                                            setTimeout(resumeCamera, 50);
                                        });
                                    }
                                });
                            }
                        });
                    });
                });
                
                mediaObserver.observe(document.body, {
                    childList: true,
                    subtree: true
                });
            }
        };

        // Handle when other media starts playing
        document.addEventListener('play', (event) => {
            if (event.target !== cameraVideo && cameraVideo.paused) {
                console.log('Other media started, resuming camera...');
                setTimeout(resumeCamera, 100);
            }
        }, true);

        // Handle visibility changes (when switching apps/tabs)
        document.addEventListener('visibilitychange', () => {
            if (!document.hidden && cameraVideo.paused && !isUserPaused) {
                console.log('Page visible again, resuming camera...');
                setTimeout(resumeCamera, 100);
            }
        });

        // Initialize media element observation
        observeMediaElements();

        // Initialize on load
        window.addEventListener('load', () => {
            initCamera();
            observeMediaElements();
        });

        // Handle iOS orientation changes
        window.addEventListener('orientationchange', () => {
            setTimeout(() => {
                const viewportHeight = window.innerHeight;
                document.documentElement.style.height = `${viewportHeight}px`;
            }, 200);
        });

        // Prevent unwanted touch behaviors on iOS
        document.addEventListener('touchmove', (e) => e.preventDefault(), { passive: false });
    </script>
</body>
</html>
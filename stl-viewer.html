<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>STL Viewer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --sat: env(safe-area-inset-top);
            --sab: env(safe-area-inset-bottom);
            --sal: env(safe-area-inset-left);
            --sar: env(safe-area-inset-right);
        }

        html {
            height: 100%;
            width: 100%;
        }

        body {
            overflow: hidden;
            background-color: #1e1e1e;
            color: #ffffff;
            font-family: Arial, sans-serif;
            touch-action: none;
            min-height: 100%;
            min-height: -webkit-fill-available;
            padding: var(--sat) var(--sar) var(--sab) var(--sal);
        }

        #container {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            width: 100vw;
            height: 100vh;
            height: -webkit-fill-available;
            padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
        }

        @media (max-width: 768px) {
            #controls {
                padding: 6px 16px;
                gap: 8px;
                flex-wrap: nowrap;
                justify-content: center;
                width: auto;
                max-width: calc(100% - 32px);
                left: 50%;
                transform: translateX(-50%);
            }

            #screenshotButton {
                position: fixed;
                left: auto;
                right: calc(50% - 24px);
                transform: translateX(calc(100% + 8px));
            }

            .control-group {
                gap: 8px;
            }

            button {
                width: 36px;
                height: 36px;
            }

            input[type="color"] {
                width: 32px;
                height: 32px;
                margin: 2px;
            }

            button svg {
                width: 16px;
                height: 16px;
            }

            label {
                display: none;
            }
        }

        #container {
            position: fixed;
            width: 100%;
            height: 100%;
        }

        #controls {
            position: fixed;
            bottom: calc(16px + var(--sab));
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 6px 16px;
            border-radius: 9999px;
            display: flex;
            flex-direction: row;
            gap: 8px;
            align-items: center;
            width: fit-content;
            max-width: calc(100% - 180px);
            backdrop-filter: blur(30px) saturate(180%);
            -webkit-backdrop-filter: blur(30px) saturate(180%);
            border: 0.5px solid rgba(255, 255, 255, 0.2);
        }

        button {
            width: 36px;
            height: 36px;
            background-color: transparent;
            color: white;
            border: none;
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 8px;
        }

        button svg {
            width: 16px;
            height: 16px;
            fill: white;
            opacity: 0.85;
            transition: all 0.2s ease;
        }

        button:active {
            background-color: rgba(255, 255, 255, 0.15);
        }

        button:hover {
            background-color: var(--model-color);
            opacity: 0.7;
        }

        button.active {
            background-color: var(--model-color);
            opacity: 1;
        }
        
        #autoRotate:not(.active):hover {
            background-color: transparent;
        }

        button:hover svg, button.active svg {
            fill: white;
            transform: scale(1.1);
        }

        /* Material Menu Styles */
        .material-menu {
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(15, 15, 15, 0.95);
            border-radius: 12px;
            padding: 8px;
            margin-bottom: 10px;
            display: none;
            flex-direction: column;
            gap: 6px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            width: 140px;
            max-height: calc(40px * 4 + 6px * 3 + 16px); /* 4 items + 3 gaps + padding */
            overflow-y: auto;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            scrollbar-width: none;
            -ms-overflow-style: none;
        }

        .material-menu.active {
            display: flex;
        }

        .material-menu::-webkit-scrollbar {
            display: none;
        }

        .color-menu {
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(15, 15, 15, 0.95);
            border-radius: 12px;
            padding: 8px;
            margin-bottom: 10px;
            display: none;
            flex-direction: column;
            gap: 6px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            width: 180px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }

        .color-menu.active {
            display: flex;
        }

        .color-option {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 0 12px;
            height: 40px;
            min-height: 40px;
            background: rgba(255, 255, 255, 0.08);
            border: none;
            border-radius: 6px;
            transition: all 0.3s ease;
            white-space: nowrap;
        }

        .color-option:hover {
            background: var(--model-color);
            opacity: 0.7;
        }

        .color-option .label-text {
            color: #ffffff;
            font-size: 15px;
            font-weight: 400;
            letter-spacing: 0.3px;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            display: inline-block;
            flex-grow: 1;
            margin-left: 12px;
        }

        .color-option input[type="color"] {
            margin: 0;
            width: 28px;
            height: 28px;
            flex-shrink: 0;
            order: -1;
        }

        .axis-menu {
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(15, 15, 15, 0.95);
            border-radius: 12px;
            padding: 8px;
            margin-bottom: 10px;
            display: none;
            grid-template-columns: repeat(2, 1fr);
            gap: 6px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            width: 120px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }

        .axis-menu.active {
            display: grid;
        }

        .axis-option {
            padding: 8px;
            color: white;
            background: rgba(255, 255, 255, 0.08);
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
            font-size: 14px;
            font-weight: 500;
            letter-spacing: 0.5px;
        }

        .axis-option:hover {
            background: var(--model-color);
            color: white;
            opacity: 0.7;
        }

        .material-option {
            padding: 0 12px;
            color: white;
            background: rgba(255, 255, 255, 0.08);
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: left;
            font-size: 13px;
            font-weight: 500;
            letter-spacing: 0.3px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            width: 100%;
            display: flex;
            align-items: center;
            height: 40px;
            min-height: 40px;
        }        .material-option:hover {
            background: var(--model-color);
            color: white;
            opacity: 0.7;
        }

        .material-option.active {
            background: var(--model-color);
            color: white;
            opacity: 1;
        }

        @keyframes rotate {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        button:hover {
            background-color: var(--model-color);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        button:active {
            transform: translateY(1px);
        }

        input[type="file"] {
            color: white;
            cursor: pointer;
            background-color: rgba(255, 255, 255, 0.1);
            padding: 10px;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            transition: all 0.3s ease;
        }

        input[type="file"]:hover {
            background-color: rgba(255, 255, 255, 0.15);
            border-color: rgba(255, 255, 255, 0.3);
        }

        button:hover {
            background-color: var(--model-color);
        }

        #screenshotButton {
            position: fixed;
            right: 16px;
            bottom: calc(16px + var(--sab));
            z-index: 99;
            background-color: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(30px) saturate(180%);
            -webkit-backdrop-filter: blur(30px) saturate(180%);
            border: 0.5px solid rgba(255, 255, 255, 0.2);
            border-radius: 9999px;
            padding: 6px 16px;
            width: 48px;
            height: 48px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        input[type="color"] {
            width: 28px;
            height: 28px;
            border: none;
            border-radius: 50%;
            cursor: pointer;
            padding: 0;
            margin: 2px;
            background: none;
            transition: transform 0.2s ease;
            overflow: hidden;
        }

        input[type="color"]::-webkit-color-swatch-wrapper {
            padding: 0;
        }

        input[type="color"]::-webkit-color-swatch {
            border: none;
            border-radius: 50%;
            padding: 0;
        }

        input[type="color"]:hover {
            transform: scale(1.1);
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 2px;
            position: relative;
        }        #loadingIndicator {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(15, 15, 15, 0.9);
            color: white;
            padding: 20px 40px;
            border-radius: 12px;
            display: none;
            align-items: center;
            gap: 12px;
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
            z-index: 1000;
        }

        .spinner {
            width: 20px;
            height: 20px;
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: white;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        label {
            font-size: 14px;
            font-weight: 500;
            color: rgba(255, 255, 255, 0.9);
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
        }
    </style>
</head>
<body>
    <div id="container"></div>
    <div id="loadingIndicator">
        <div class="spinner"></div>
        <span>Loading model...</span>
    </div>
    <div id="controls">
        <div class="control-group">
            <input type="file" id="fileInput" accept=".stl" style="display: none;" />
            <button id="uploadButton" title="Upload STL" onclick="document.getElementById('fileInput').click();">
                <svg viewBox="0 0 24 24">
                    <path d="M9 16h6v-6h4l-7-7-7 7h4v6zm-4 2h14v2H5v-2z"/>
                </svg>
            </button>
        </div>
        <div class="control-group color-picker-group">
            <button id="colorPickerBtn" title="Change Colors">
                <svg viewBox="0 0 24 24">
                    <path d="M12 22C6.49 22 2 17.51 2 12S6.49 2 12 2s10 4.04 10 9c0 3.31-2.69 6-6 6h-1.77c-.28 0-.5.22-.5.5 0 .12.05.23.13.33.41.47.64 1.06.64 1.67A2.5 2.5 0 0 1 12 22zm0-18c-4.41 0-8 3.59-8 8s3.59 8 8 8c.28 0 .5-.22.5-.5a.54.54 0 0 0-.14-.35c-.41-.46-.63-1.05-.63-1.65a2.5 2.5 0 0 1 2.5-2.5H16c2.21 0 4-1.79 4-4 0-3.86-3.59-7-8-7z"/>
                    <circle cx="6.5" cy="11.5" r="1.5"/>
                    <circle cx="9.5" cy="7.5" r="1.5"/>
                    <circle cx="14.5" cy="7.5" r="1.5"/>
                    <circle cx="17.5" cy="11.5" r="1.5"/>
                </svg>
            </button>
            <div class="color-menu" id="colorMenu">
                <div class="color-option">
                    <input type="color" id="bgColor" value="#1e1e1e" />
                    <span class="label-text">Background</span>
                </div>
                <div class="color-option">
                    <input type="color" id="modelColor" value="#00ff00" />
                    <span class="label-text">Model</span>
                </div>
            </div>
        </div>
        <div class="control-group" style="position: relative;">
            <button id="materialBtn" title="Change Material">
                <svg viewBox="0 0 24 24">
                    <path d="M12 2L2 7l10 5 10-5-10-5zM2 17l10 5 10-5M2 12l10 5 10-5"/>
                </svg>
            </button>
        </div>
        <div class="control-group" style="position: relative;">
            <button id="axisSnapBtn" title="Snap to Axis">
                <svg viewBox="0 0 24 24">
                    <path d="M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 16H5V5h14v14z"/>
                    <path d="M7 7h2v2H7zm4 0h2v2h-2zm4 0h2v2h-2zM7 11h2v2H7zm4 0h2v2h-2zm4 0h2v2h-2zM7 15h2v2H7zm4 0h2v2h-2zm4 0h2v2h-2z"/>
                </svg>
            </button>
            <div class="axis-menu" id="axisMenu">
                <button class="axis-option" data-axis="x">+X</button>
                <button class="axis-option" data-axis="-x">-X</button>
                <button class="axis-option" data-axis="y">+Y</button>
                <button class="axis-option" data-axis="-y">-Y</button>
                <button class="axis-option" data-axis="z">+Z</button>
                <button class="axis-option" data-axis="-z">-Z</button>
            </div>
        </div>
        <div class="control-group">
            <button id="autoRotate" title="Auto Rotate">
                <svg viewBox="0 0 24 24">
                    <path d="M12 4V1L8 5l4 4V6c3.31 0 6 2.69 6 6 0 1.01-.25 1.97-.7 2.8l1.46 1.46C19.54 15.03 20 13.57 20 12c0-4.42-3.58-8-8-8zm0 14c-3.31 0-6-2.69-6-6 0-1.01.25-1.97.7-2.8L5.24 7.74C4.46 8.97 4 10.43 4 12c0 4.42 3.58 8 8 8v3l4-4-4-4v3z"/>
                </svg>
            </button>
        </div>
        <div class="control-group">
            <button id="resetCamera" title="Reset Camera">
                <svg viewBox="0 0 24 24">
                    <path d="M12 7C6.48 7 2 9.24 2 12c0 2.24 2.94 4.13 7 4.77V20l4-4-4-4v3.73c-3.17-.56-5-1.81-5-2.73 0-1.06 3.04-3 8-3s8 1.94 8 3c0 .73-1.46 1.89-4 2.53v2.05c3.53-.77 6-2.53 6-4.58 0-2.76-4.48-5-10-5z"/>
                </svg>
            </button>
        </div>
        <div class="control-group">
            <button id="clearModel" title="Clear Model">
                <svg viewBox="0 0 24 24">
                    <path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z"/>
                </svg>
            </button>
        </div>
            <div class="material-menu" id="materialMenu">
                <button class="material-option" data-material="foamyTPU">Foamy TPU</button>
                <button class="material-option" data-material="regularTPU">Regular TPU</button>
                <button class="material-option" data-material="rubber">Rubber</button>
                <button class="material-option" data-material="wireframe">Wireframe</button>
                <button class="material-option" data-material="glossyLeather">Glossy Leather</button>
                <button class="material-option" data-material="matteLeather">Matte Leather</button>
                <button class="material-option" data-material="suede">Suede</button>
                <button class="material-option" data-material="canvas">Canvas</button>
                <button class="material-option" data-material="mesh">Mesh</button>
                <button class="material-option" data-material="plastic">Plastic</button>
                <button class="material-option" data-material="metal">Metal</button>
                <button class="material-option" data-material="carbonFiber">Carbon Fiber</button>
            </div>
        </div>
    </div>

    <button id="screenshotButton" title="Take Screenshot">
        <svg viewBox="0 0 24 24">
            <path d="M12 8.8l-2.5 3.2h5L12 8.8zm0 0"/>
            <path d="M9 3L7.17 5H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2h-3.17L15 3H9zm3 15c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5z"/>
        </svg>
    </button>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.157.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.157.0/examples/jsm/",
                "three/examples/": "https://unpkg.com/three@0.157.0/examples/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { STLLoader } from 'three/addons/loaders/STLLoader.js';

        // Scene setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.getElementById('container').appendChild(renderer.domElement);

        // Studio Lighting Setup
        const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
        scene.add(ambientLight);

        // Main Key Light (front-right-top)
        const keyLight = new THREE.DirectionalLight(0xffffff, 1.0);
        keyLight.position.set(2, 2, 2);
        keyLight.castShadow = true;
        scene.add(keyLight);

        // Fill Light (front-left)
        const fillLight = new THREE.DirectionalLight(0xffffff, 0.6);
        fillLight.position.set(-2, 0, 2);
        scene.add(fillLight);

        // Back Light (rim light)
        const backLight = new THREE.DirectionalLight(0xffffff, 0.4);
        backLight.position.set(0, 3, -2);
        scene.add(backLight);

        // Ground Reflection
        const groundReflection = new THREE.DirectionalLight(0xffffff, 0.2);
        groundReflection.position.set(0, -2, 0);
        scene.add(groundReflection);

        // Soft Fill Light (hemisphere)
        const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.4);
        scene.add(hemiLight);

        // Camera and controls setup
        camera.position.z = 5;
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;

        // Variables for model
        let currentModel = null;
        const loader = new STLLoader();

        // Loading indicator functions
        const loadingIndicator = document.getElementById('loadingIndicator');
        
        function showLoading() {
            loadingIndicator.style.display = 'flex';
        }
        
        function hideLoading() {
            loadingIndicator.style.display = 'none';
        }

        // Function to save uploaded STL file
        function saveSTLFile(file) {
            const reader = new FileReader();
            reader.onload = function(e) {
                const base64data = e.target.result;
                localStorage.setItem('lastUploadedSTL', base64data);
                localStorage.setItem('lastSTLName', file.name);
            };
            reader.readAsDataURL(file);
        }

        // Function to load and display STL file
        function loadAndDisplaySTL(geometry) {
            // Remove existing model if present
            if (currentModel) {
                scene.remove(currentModel);
            }

            const preset = materialPresets[currentMaterialType];
            const material = new THREE[preset.type === 'MeshPhysicalMaterial' ? 'MeshPhysicalMaterial' : 'MeshBasicMaterial']({
                ...preset.properties,
                color: document.getElementById('modelColor').value
            });

            const mesh = new THREE.Mesh(geometry, material);
            
            // Center the model properly
            geometry.computeBoundingBox();
            const boundingBox = new THREE.Box3().setFromObject(mesh);
            const center = new THREE.Vector3();
            boundingBox.getCenter(center);
            
            // Move geometry to origin
            geometry.translate(-center.x, -center.y, -center.z);
            
            // Scale model to fit view
            const size = boundingBox.getSize(new THREE.Vector3());
            const maxDim = Math.max(size.x, size.y, size.z);
            const scale = 5 / maxDim;
            mesh.scale.multiplyScalar(scale);
            
            // Ensure the model's position is at origin
            mesh.position.set(0, 0, 0);

            currentModel = mesh;
            scene.add(currentModel);

            // Set up camera and controls for proper rotation
            const modelBoundingBox = new THREE.Box3().setFromObject(mesh);
            const modelCenter = new THREE.Vector3();
            modelBoundingBox.getCenter(modelCenter);
            
            // Set controls target to model center
            controls.target.copy(modelCenter);
            
            // Position camera relative to model center
            const distance = modelBoundingBox.getSize(new THREE.Vector3()).length() * 1.5;
            camera.position.set(
                modelCenter.x + distance,
                modelCenter.y + distance,
                modelCenter.z + distance
            );
            
            camera.lookAt(modelCenter);
            camera.updateProjectionMatrix();
            controls.update();
            
            // Hide loading indicator
            hideLoading();
        }

        // File persistence functions
        function saveFileToStorage(file) {
            const reader = new FileReader();
            reader.onload = function(e) {
                const base64data = e.target.result.split(',')[1];
                localStorage.setItem('stlViewerFile', base64data);
                localStorage.setItem('stlViewerFileName', file.name);
            };
            reader.readAsDataURL(file);
        }

        function loadFileFromStorage() {
            const base64data = localStorage.getItem('stlViewerFile');
            if (!base64data) return null;

            const binary = atob(base64data);
            const bytes = new Uint8Array(binary.length);
            for (let i = 0; i < binary.length; i++) {
                bytes[i] = binary.charCodeAt(i);
            }
            return new Blob([bytes.buffer], { type: 'model/stl' });
        }

        // Handle file input
        document.getElementById('fileInput').addEventListener('change', function(event) {
            showLoading();
            const file = event.target.files[0];
            if (file) {
                saveFileToStorage(file);
                const reader = new FileReader();
                reader.onload = function(e) {
                    loader.load(
                        URL.createObjectURL(file),
                        function(geometry) {
                            loadAndDisplaySTL(geometry);
                            saveSTLFile(file);
                        },
                        (xhr) => {
                            console.log((xhr.loaded / xhr.total * 100) + '% loaded');
                        },
                        (error) => {
                            console.error('Error loading STL:', error);
                            hideLoading();
                        }
                    );
                };
                reader.readAsArrayBuffer(file);
            }
        });

        // Handle background color change
        document.getElementById('bgColor').addEventListener('change', function(event) {
            const color = event.target.value;
            scene.background = new THREE.Color(color);
            document.body.style.backgroundColor = color;
            saveColorPreference('background', color);
        });

        // Handle model color change
        const modelColorInput = document.getElementById('modelColor');
        
        function updateModelColor(color) {
            if (currentModel) {
                currentModel.material.color.setStyle(color);
            }
            document.documentElement.style.setProperty('--model-color', color);
            saveColorPreference('model', color);
        }

        // Listen for both change and input events
        modelColorInput.addEventListener('change', function(event) {
            updateModelColor(event.target.value);
        });

        modelColorInput.addEventListener('input', function(event) {
            updateModelColor(event.target.value);
        });

        // Initialize model color variable on load
        document.documentElement.style.setProperty(
            '--model-color', 
            document.getElementById('modelColor').value
        );

        // Reset camera position
        function resetCamera() {
            if (currentModel) {
                const boundingBox = new THREE.Box3().setFromObject(currentModel);
                const center = new THREE.Vector3();
                boundingBox.getCenter(center);
                
                // Calculate proper camera distance based on model size
                const size = boundingBox.getSize(new THREE.Vector3());
                const maxDim = Math.max(size.x, size.y, size.z);
                const distance = maxDim * 2;
                
                // Position camera at an isometric view
                camera.position.set(
                    center.x + distance,
                    center.y + distance,
                    center.z + distance
                );
                
                // Ensure controls target is at model center
                controls.target.copy(center);
                camera.lookAt(center);
                camera.updateProjectionMatrix();
                controls.update();
            }
        }

        document.getElementById('resetCamera').addEventListener('click', resetCamera);

        // Handle window resize and device orientation changes
        window.addEventListener('resize', onWindowResize, false);
        window.addEventListener('orientationchange', () => {
            setTimeout(onWindowResize, 100);
        });

        // Mobile touch support
        function setupTouchControls() {
            let lastTouchX = 0;
            let lastTouchY = 0;
            let velocityX = 0;
            let velocityY = 0;
            let isDragging = false;
            let lastTime = 0;
            let inertiaFrame;

            function applyInertia() {
                velocityX *= 0.95;
                velocityY *= 0.95;
                if (Math.abs(velocityX) > 0.01 || Math.abs(velocityY) > 0.01) {
                    controls.rotateLeft(velocityX * 0.008);
                    controls.rotateUp(velocityY * 0.008);
                    inertiaFrame = requestAnimationFrame(applyInertia);
                } else {
                    velocityX = 0;
                    velocityY = 0;
                    inertiaFrame = null;
                }
            }

            container.addEventListener('touchstart', (e) => {
                const touch = e.touches[0];
                lastTouchX = touch.clientX;
                lastTouchY = touch.clientY;
                isDragging = true;
                lastTime = performance.now();
                if (inertiaFrame) {
                    cancelAnimationFrame(inertiaFrame);
                    inertiaFrame = null;
                }
            }, { passive: true });

            container.addEventListener('touchmove', (e) => {
                if (!isDragging) return;
                const touch = e.touches[0];
                const now = performance.now();
                const dt = Math.max(now - lastTime, 16);
                const deltaX = touch.clientX - lastTouchX;
                const deltaY = touch.clientY - lastTouchY;

                // Increase sensitivity for mobile
                controls.rotateLeft(deltaX * 0.012);
                controls.rotateUp(deltaY * 0.012);

                // Calculate velocity for inertia
                velocityX = deltaX / dt * 16;
                velocityY = deltaY / dt * 16;

                lastTouchX = touch.clientX;
                lastTouchY = touch.clientY;
                lastTime = now;

                if (e.touches.length === 2) {
                    // Pinch to zoom
                    const touch2 = e.touches[1];
                    const dist = Math.hypot(
                        touch2.clientX - touch.clientX,
                        touch2.clientY - touch.clientY
                    );
                    controls.dollyOut(1 + dist * 0.001);
                }
            }, { passive: true });

            container.addEventListener('touchend', () => {
                isDragging = false;
                if (!inertiaFrame && (Math.abs(velocityX) > 0.01 || Math.abs(velocityY) > 0.01)) {
                    inertiaFrame = requestAnimationFrame(applyInertia);
                }
            }, { passive: true });
        }

        setupTouchControls();

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // Auto-rotation control
        let autoRotating = false;
        const autoRotateBtn = document.getElementById('autoRotate');

        autoRotateBtn.addEventListener('click', () => {
            autoRotating = !autoRotating;
            autoRotateBtn.classList.toggle('active');
            controls.autoRotate = autoRotating;
            controls.autoRotateSpeed = 8.0; // Increased rotation speed
        });

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        // Color picker management
        const colorPickerBtn = document.getElementById('colorPickerBtn');
        const colorMenu = document.getElementById('colorMenu');

        colorPickerBtn.addEventListener('click', () => {
            colorMenu.classList.toggle('active');
        });

        // Close color menu when clicking outside
        document.addEventListener('click', (e) => {
            if (!colorPickerBtn.contains(e.target) && !colorMenu.contains(e.target)) {
                colorMenu.classList.remove('active');
            }
        });

        // Color preference management
        function loadColorPreferences() {
            const savedBgColor = localStorage.getItem('stlViewerBgColor') || '#1e1e1e';
            const savedModelColor = localStorage.getItem('stlViewerModelColor') || '#00ff00';
            
            document.getElementById('bgColor').value = savedBgColor;
            document.getElementById('modelColor').value = savedModelColor;
            
            // Initialize the CSS variable for button highlights
            document.documentElement.style.setProperty('--model-color', savedModelColor);
            
            scene.background = new THREE.Color(savedBgColor);
            document.body.style.backgroundColor = savedBgColor;
            if (currentModel) {
                currentModel.material.color.setStyle(savedModelColor);
            }
            return { bgColor: savedBgColor, modelColor: savedModelColor };
        }

        function saveColorPreference(type, color) {
            localStorage.setItem(
                type === 'background' ? 'stlViewerBgColor' : 'stlViewerModelColor',
                color
            );
        }

        // Load saved colors
        const savedColors = loadColorPreferences();

        // Material handling
        const materialBtn = document.getElementById('materialBtn');
        const materialMenu = document.getElementById('materialMenu');
        let currentMaterialType = 'regularTPU';

        // Material presets
        const materialPresets = {
            foamyTPU: {
                type: 'MeshPhysicalMaterial',
                properties: {
                    metalness: 0.0,
                    roughness: 0.7,
                    clearcoat: 0.1,
                    clearcoatRoughness: 0.8,
                    transmission: 0.1,
                    thickness: 0.5,
                    reflectivity: 0.2,
                    sheen: 1.0,
                    sheenRoughness: 0.9,
                    sheenColor: 0xffffff
                }
            },
            regularTPU: {
                type: 'MeshPhysicalMaterial',
                properties: {
                    metalness: 0.1,
                    roughness: 0.3,
                    clearcoat: 0.3,
                    clearcoatRoughness: 0.2,
                    transmission: 0.2,
                    reflectivity: 0.5,
                    envMapIntensity: 0.5
                }
            },
            rubber: {
                type: 'MeshPhysicalMaterial',
                properties: {
                    metalness: 0.0,
                    roughness: 0.9,
                    clearcoat: 0.0,
                    reflectivity: 0.1,
                    sheen: 0.3,
                    sheenRoughness: 0.8
                }
            },
            wireframe: {
                type: 'MeshBasicMaterial',
                properties: {
                    wireframe: true,
                    wireframeLinewidth: 1
                }
            },
            glossyLeather: {
                type: 'MeshPhysicalMaterial',
                properties: {
                    metalness: 0.0,
                    roughness: 0.3,
                    clearcoat: 0.7,
                    clearcoatRoughness: 0.2,
                    reflectivity: 0.5,
                    sheen: 0.5,
                    sheenRoughness: 0.3
                }
            },
            matteLeather: {
                type: 'MeshPhysicalMaterial',
                properties: {
                    metalness: 0.0,
                    roughness: 0.7,
                    clearcoat: 0.1,
                    clearcoatRoughness: 0.8,
                    reflectivity: 0.2,
                    sheen: 0.3,
                    sheenRoughness: 0.7
                }
            },
            suede: {
                type: 'MeshPhysicalMaterial',
                properties: {
                    metalness: 0.0,
                    roughness: 1.0,
                    clearcoat: 0.0,
                    reflectivity: 0.1,
                    sheen: 1.0,
                    sheenRoughness: 1.0,
                    sheenColor: 0xffffff
                }
            },
            canvas: {
                type: 'MeshPhysicalMaterial',
                properties: {
                    metalness: 0.0,
                    roughness: 0.9,
                    clearcoat: 0.0,
                    reflectivity: 0.1,
                    sheen: 0.2,
                    sheenRoughness: 0.9
                }
            },
            mesh: {
                type: 'MeshPhysicalMaterial',
                properties: {
                    metalness: 0.1,
                    roughness: 0.6,
                    clearcoat: 0.0,
                    transmission: 0.2,
                    thickness: 0.2,
                    reflectivity: 0.2
                }
            },
            plastic: {
                type: 'MeshPhysicalMaterial',
                properties: {
                    metalness: 0.0,
                    roughness: 0.2,
                    clearcoat: 0.4,
                    clearcoatRoughness: 0.2,
                    transmission: 0.1,
                    reflectivity: 0.7
                }
            },
            metal: {
                type: 'MeshPhysicalMaterial',
                properties: {
                    metalness: 0.9,
                    roughness: 0.2,
                    clearcoat: 1.0,
                    clearcoatRoughness: 0.1,
                    reflectivity: 1.0,
                    envMapIntensity: 1.0
                }
            },
            carbonFiber: {
                type: 'MeshPhysicalMaterial',
                properties: {
                    metalness: 0.4,
                    roughness: 0.4,
                    clearcoat: 1.0,
                    clearcoatRoughness: 0.1,
                    reflectivity: 0.7,
                    sheen: 0.3,
                    sheenRoughness: 0.3
                }
            }
        };

        function updateModelMaterial(materialType) {
            if (!currentModel) return;
            
            const preset = materialPresets[materialType];
            const color = document.getElementById('modelColor').value;
            
            let material;
            if (preset.type === 'MeshPhysicalMaterial') {
                material = new THREE.MeshPhysicalMaterial({
                    ...preset.properties,
                    color: color
                });
            } else {
                material = new THREE.MeshBasicMaterial({
                    ...preset.properties,
                    color: color
                });
            }
            
            currentModel.material = material;
            currentMaterialType = materialType;

            // Update active state in menu
            document.querySelectorAll('.material-option').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.material === materialType);
            });
        }

        // Material menu toggle
        materialBtn.addEventListener('click', () => {
            materialMenu.classList.toggle('active');
        });

        // Close material menu when clicking outside
        document.addEventListener('click', (e) => {
            if (!materialBtn.contains(e.target) && !materialMenu.contains(e.target)) {
                materialMenu.classList.remove('active');
            }
        });

        // Material option selection
        document.querySelectorAll('.material-option').forEach(button => {
            button.addEventListener('click', () => {
                updateModelMaterial(button.dataset.material);
                materialMenu.classList.remove('active');
            });
        });

        // Update CSS variable for button highlights when model color changes
        document.getElementById('modelColor').addEventListener('input', function(event) {
            document.documentElement.style.setProperty('--model-color', `${event.target.value}33`);
        });

        // Load saved or default STL file
        const savedFile = loadFileFromStorage();
        const fileToLoad = savedFile ? URL.createObjectURL(savedFile) : 'cube.stl';

        loader.load(
            fileToLoad,
            function(geometry) {
                const material = new THREE.MeshPhongMaterial({
                    color: document.getElementById('modelColor').value,
                    specular: 0x111111,
                    shininess: 200
                });

                const mesh = new THREE.Mesh(geometry, material);
                
                // Center and scale the model
                geometry.computeBoundingBox();
                const center = new THREE.Vector3();
                geometry.boundingBox.getCenter(center);
                geometry.center();
                
                const boundingBox = new THREE.Box3().setFromObject(mesh);
                const size = boundingBox.getSize(new THREE.Vector3());
                const maxDim = Math.max(size.x, size.y, size.z);
                const scale = 5 / maxDim;
                mesh.scale.multiplyScalar(scale);

                currentModel = mesh;
                scene.add(currentModel);
                resetCamera();
            },
            (xhr) => {
                console.log((xhr.loaded / xhr.total * 100) + '% loaded');
            },
            (error) => {
                console.log('No default STL file found, waiting for user input');
            }
        );

        // Axis snap functionality
        const axisSnapBtn = document.getElementById('axisSnapBtn');
        const axisMenu = document.getElementById('axisMenu');

        axisSnapBtn.addEventListener('click', () => {
            axisMenu.classList.toggle('active');
        });

        // Close axis menu when clicking outside
        document.addEventListener('click', (e) => {
            if (!axisSnapBtn.contains(e.target) && !axisMenu.contains(e.target)) {
                axisMenu.classList.remove('active');
            }
        });

        function snapToAxis(axis) {
            if (!currentModel) return;

            // Calculate the bounding box to get the center
            const boundingBox = new THREE.Box3().setFromObject(currentModel);
            const center = new THREE.Vector3();
            boundingBox.getCenter(center);

            // Set up the camera position based on the axis
            const distance = camera.position.distanceTo(controls.target);
            const positions = {
                'x': [distance, 0, 0],
                '-x': [-distance, 0, 0],
                'y': [0, distance, 0],
                '-y': [0, -distance, 0],
                'z': [0, 0, distance],
                '-z': [0, 0, -distance]
            };

            const pos = positions[axis];
            camera.position.set(center.x + pos[0], center.y + pos[1], center.z + pos[2]);
            controls.target.copy(center);

            // Ensure up vector is correct
            if (axis === 'y' || axis === '-y') {
                camera.up.set(0, 0, 1);
            } else {
                camera.up.set(0, 1, 0);
            }

            camera.updateProjectionMatrix();
            controls.update();
        }

        // Add click handlers for axis snap buttons
        document.querySelectorAll('.axis-option').forEach(button => {
            button.addEventListener('click', () => {
                snapToAxis(button.dataset.axis);
                axisMenu.classList.remove('active');
            });
        });

        // Clear model handler
        document.getElementById('clearModel').addEventListener('click', () => {
            if (currentModel) {
                scene.remove(currentModel);
                currentModel = null;
            }
            localStorage.removeItem('stlViewerFile');
            localStorage.removeItem('stlViewerFileName');

            // Load default cube
            loader.load('cube.stl',
                function(geometry) {
                    const material = new THREE.MeshPhongMaterial({
                        color: document.getElementById('modelColor').value,
                        specular: 0x111111,
                        shininess: 200
                    });

                    const mesh = new THREE.Mesh(geometry, material);
                    geometry.computeBoundingBox();
                    const center = new THREE.Vector3();
                    geometry.boundingBox.getCenter(center);
                    geometry.center();
                    
                    const boundingBox = new THREE.Box3().setFromObject(mesh);
                    const size = boundingBox.getSize(new THREE.Vector3());
                    const maxDim = Math.max(size.x, size.y, size.z);
                    const scale = 5 / maxDim;
                    mesh.scale.multiplyScalar(scale);

                    currentModel = mesh;
                    scene.add(currentModel);
                    resetCamera();
                },
                (xhr) => {
                    console.log((xhr.loaded / xhr.total * 100) + '% loaded');
                },
                (error) => {
                    console.error('Error loading default STL:', error);
                }
            );
        });

        // Screenshot functionality
        const screenshotButton = document.getElementById('screenshotButton');
        
        function takeScreenshot() {
            // Temporarily hide controls
            const controls = document.getElementById('controls');
            const screenshotBtn = document.getElementById('screenshotButton');
            controls.style.display = 'none';
            screenshotBtn.style.display = 'none';
            
            // Render the scene
            renderer.render(scene, camera);
            
            // Create a new canvas with only the WebGL content
            const canvas = renderer.domElement;
            
            // Convert to blob
            canvas.toBlob((blob) => {
                // Show controls again
                controls.style.display = 'flex';
                screenshotBtn.style.display = 'flex';
                
                // For iOS, use specific API to save to photo library
                if (navigator.userAgent.match(/(iPhone|iPod|iPad)/i)) {
                    const url = URL.createObjectURL(blob);
                    const img = new Image();
                    img.onload = () => {
                        // Create a canvas to draw the image
                        const canvas = document.createElement('canvas');
                        canvas.width = img.width;
                        canvas.height = img.height;
                        const ctx = canvas.getContext('2d');
                        ctx.drawImage(img, 0, 0);
                        
                        // Convert to base64 and save to photos
                        const dataUrl = canvas.toDataURL('image/png');
                        
                        // Create invisible link for downloading
                        const a = document.createElement('a');
                        a.href = dataUrl;
                        a.download = 'stl-model-screenshot.png';
                        document.body.appendChild(a);
                        a.click();
                        document.body.removeChild(a);
                        URL.revokeObjectURL(url);
                    };
                    img.src = url;
                } else {
                    // For other platforms, trigger download
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = 'stl-model-screenshot.png';
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                }
            }, 'image/png', 1.0);
        }

        screenshotButton.addEventListener('click', takeScreenshot);

        animate();
    </script>
</body>
</html>